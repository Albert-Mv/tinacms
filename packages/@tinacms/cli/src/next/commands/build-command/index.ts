import fetch, { Headers } from 'node-fetch'
import { Command, Option } from 'clipanion'
import Progress from 'progress'
import fs from 'fs-extra'
import { buildSchema, getASTSchema, Database } from '@tinacms/graphql'
import { ConfigManager } from '../../config-manager'
import { logger, summary } from '../../../logger'
import { buildProductionSpa } from './server'
import { Codegen } from '../../codegen'
import { parseURL } from '@tinacms/schema-tools'
import {
  buildASTSchema,
  buildClientSchema,
  getIntrospectionQuery,
} from 'graphql'
import { diff } from '@graphql-inspector/core'
import { waitForDB } from './waitForDB'
import { createAndInitializeDatabase, createDBServer } from '../../database'

export class BuildCommand extends Command {
  static paths = [['build']]
  rootPath = Option.String('--rootPath', {
    description:
      'Specify the root directory to run the CLI from (defaults to current working directory)',
  })
  verbose = Option.Boolean('-v,--verbose', false, {
    description: 'increase verbosity of logged output',
  })
  noSDK = Option.Boolean('--noSDK', false, {
    description: "Don't generate the generated client SDK",
  })
  noTelemetry = Option.Boolean('--noTelemetry', false, {
    description: 'Disable anonymous telemetry that is collected',
  })
  tinaGraphQLVersion = Option.String('--tina-graphql-version', {
    description:
      'Specify the version of @tinacms/graphql to use (defaults to latest)',
  })

  static usage = Command.Usage({
    category: `Commands`,
    description: `Build the CMS and autogenerated modules for usage with Tina Cloud`,
  })

  async catch(error: any): Promise<void> {
    console.error(error)
    process.exit(1)
  }

  async execute(): Promise<number | void> {
    const configManager = new ConfigManager(
      this.rootPath,
      this.tinaGraphQLVersion
    )
    logger.info('Starting Tina build')

    try {
      await configManager.processConfig()
    } catch (e) {
      logger.error(e.message)
      logger.error('Unable to build, please fix your Tina config and try again')
      process.exit(1)
    }

    // Initialize the host TCP server
    createDBServer()
    const database = await createAndInitializeDatabase(configManager)
    const { queryDoc, fragDoc } = await buildSchema(
      database,
      configManager.config
    )

    const codegen = new Codegen({
      schema: await getASTSchema(database),
      configManager: configManager,
      noSDK: this.noSDK,
      queryDoc,
      fragDoc,
    })
    const apiURL = await codegen.execute()

    await this.checkClientInfo(configManager, apiURL)
    await waitForDB(configManager.config, apiURL, false)
    await this.checkGraphqlSchema(configManager, database, apiURL)

    await buildProductionSpa(configManager, database, apiURL, this.noSDK)

    // Add the gitignore so the index.html and assets are committed to git
    await fs.outputFile(
      configManager.outputGitignorePath,
      'index.html\nassets/'
    )

    const summaryItems = []
    if (!this.noSDK) {
      summaryItems.push({
        emoji: 'ü§ñ',
        heading: 'Auto-generated files',
        subItems: [
          {
            key: 'GraphQL Client',
            value: configManager.printGeneratedClientFilePath(),
          },
          {
            key: 'Typescript Types',
            value: configManager.printGeneratedTypesFilePath(),
          },
        ],
      })
    }

    summary({
      heading: 'Tina build complete',
      items: [
        {
          emoji: 'ü¶ô',
          heading: 'Tina Config',
          subItems: [
            {
              key: 'API url',
              value: apiURL,
            },
          ],
        },
        ...summaryItems,
        // {
        //   emoji: 'üìö',
        //   heading: 'Useful links',
        //   subItems: [
        //     {
        //       key: 'Custom queries',
        //       value: 'https://tina.io/querying',
        //     },
        //     {
        //       key: 'Visual editing',
        //       value: 'https://tina.io/visual-editing',
        //     },
        //   ],
        // },
      ],
    })
    process.exit()
  }

  async checkClientInfo(configManager: ConfigManager, apiURL: string) {
    const { config } = configManager
    const token = config.token
    const { clientId, branch, host } = parseURL(apiURL)
    const url = `https://${host}/db/${clientId}/status/${branch}`
    const bar = new Progress('Checking clientId, token and branch. :prog', 1)

    try {
      await request({
        token,
        url,
      })
      bar.tick({
        prog: '‚úÖ',
      })
    } catch (e) {
      summary({
        heading: 'Error when checking client information',
        items: [
          {
            emoji: '‚ùå',
            heading: 'You provided',
            subItems: [
              {
                key: 'branch',
                value: config.branch,
              },
              {
                key: 'clientId',
                value: config.clientId,
              },
              {
                key: 'token',
                value: config.token,
              },
            ],
          },
        ],
      })
      throw e
    }
  }

  async checkGraphqlSchema(
    configManager: ConfigManager,
    database: Database,
    apiURL: string
  ) {
    const bar = new Progress(
      'Checking local GraphQL Schema matches server. :prog',
      1
    )
    const { config } = configManager
    const token = config.token

    // Get the remote schema from the graphql endpoint
    const remoteSchema = await fetchRemoteGraphqlSchema({
      url: apiURL,
      token,
    })

    const remoteGqlSchema = buildClientSchema(remoteSchema)

    // This will always be the filesystem bridge.
    const localSchemaDocument = await database.getGraphQLSchemaFromBridge()
    const localGraphqlSchema = buildASTSchema(localSchemaDocument)
    const diffResult = await diff(localGraphqlSchema, remoteGqlSchema)

    if (diffResult.length === 0) {
      bar.tick({
        prog: '‚úÖ',
      })
    } else {
      bar.tick({
        prog: '‚ùå',
      })
      let errorMessage = `The local GraphQL schema doesn't match the remote GraphQL schema. Please push up your changes to Github to update your remote GraphQL schema.`
      if (config?.branch) {
        errorMessage += `\n\nAdditional info: Branch: ${config.branch}, Client ID: ${config.clientId} `
      }
      throw new Error(errorMessage)
    }
  }
}

//  This was taken from packages/tinacms/src/unifiedClient/index.ts
// TODO: maybe move this to a shared util package?
async function request(args: {
  url: string
  token: string
}): Promise<{ status: string; timestamp: number }> {
  const headers = new Headers()
  if (args.token) {
    headers.append('X-API-KEY', args.token)
  }
  headers.append('Content-Type', 'application/json')

  const url = args?.url

  const res = await fetch(url, {
    method: 'GET',
    headers,
    redirect: 'follow',
  })
  const json = await res.json()
  if (!res.ok) {
    let additionalInfo = ''
    if (res.status === 401 || res.status === 403) {
      additionalInfo =
        'Please check that your client ID, URL and read only token are configured properly.'
    }
    if (json) {
      additionalInfo += `\n\nMessage from server: ${json.message}`
    }
    throw new Error(
      `Server responded with status code ${res.status}, ${res.statusText}. ${
        additionalInfo ? additionalInfo : ''
      } Please see our FAQ for more information: https://tina.io/docs/errors/faq/`
    )
  }
  if (json.errors) {
    throw new Error(
      `Unable to fetch, please see our FAQ for more information: https://tina.io/docs/errors/faq/

      Errors: \n\t${json.errors.map((error) => error.message).join('\n')}`
    )
  }
  return {
    status: json?.status,
    timestamp: json?.timestamp,
  }
}

export const fetchRemoteGraphqlSchema = async ({
  url,
  token,
}: {
  url: string
  token?: string
}) => {
  const headers = new Headers()
  if (token) {
    headers.append('X-API-KEY', token)
  }
  const body = JSON.stringify({ query: getIntrospectionQuery(), variables: {} })

  headers.append('Content-Type', 'application/json')

  const res = await fetch(url, {
    method: 'POST',
    headers,
    body,
  })
  const data = await res.json()
  return data?.data
}
